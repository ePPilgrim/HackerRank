using System;
using System.Collections.Generic;
using System.Linq;
using Moq;
using Shouldly;
using SimCorp.IMS.MiddleOffice.Engine.Api;
using SimCorp.IMS.MiddleOffice.Engine.Api.Common;
using SimCorp.IMS.MiddleOffice.Engine.Facade;
using SimCorp.IMS.MiddleOffice.Engine.Facade.Common;
using SimCorp.IMS.Framework.DataSharing;
using SimCorp.IMS.Framework.Data;
using SimCorp.IMS.Framework.DataSharing.Service.Implementation;
using SimCorp.IMS.Framework.DataSharing.Queryable;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace SimCorp.IMS.MiddleOffice.Engine.Api.Test {
    [TestClass]
    public class DataSourceAdapterCalculationEngineTest {

        public DataSourceAdapterCalculationEngineTest() {
            userDataManager.Setup(x => x.Find(It.IsAny<User.KeySet>())).Returns(() => Mock.Of<IUser>());
        }

        private delegate bool comSelect(string Id, string Title, FormatType FormatType, string TypeName, string CurrencyTypeName, string PeriodName, IDictionary<string, Array> Result);

        private Mock<IDataManager<IUser>> userDataManager = new Mock<IDataManager<IUser>>();  

        [TestMethod]
        public void SelectFromTypes() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            comSelect Comp = (a1, a2, a3, a4, a5, a6, res) => {
                bool flag = res["Id"].GetValue(0).Equals(a1) && (res["Id"].Length == 1);
                flag = flag && res["Title"].GetValue(0).Equals(a2) && (res["Title"].Length == 1);
                flag = flag && res["FormatType"].GetValue(0).Equals((int)a3) && (res["FormatType"].Length == 1);
                flag = flag && res["TypeName"].GetValue(0).Equals(a4) && (res["TypeName"].Length == 1);
                flag = flag && res["CurrencyTypeName"].GetValue(0).Equals(a5) && (res["CurrencyTypeName"].Length == 1);
                flag = flag && res["PeriodName"].GetValue(0).Equals(a6) && (res["PeriodName"].Length == 1);
                return flag;
            };

            var query = new QueryData() {
                EntityName = "Analytics",
                PropertyPaths = new[] { "Id", "Title", "FormatType", "TypeName", "CurrencyTypeName", "PeriodName" },
                Filter = null,
                MaxCount = 1000
            };

            query.Filter = "Id in (\"IRR\") and FormatType in (Numeric) and CurrencyTypeName in (\"QC\") and PeriodName in (\"Month\")";
            var result = dataSource.SelectAsync(credentials, query).Result.Data;
            Assert.IsTrue(Comp("IRR", "IRR", FormatType.Numeric, "Numeric", "QC", "Month", result));

            query.Filter = "Id in (\"AnualIRR\") and FormatType in (Numeric) and CurrencyTypeName in (\"PC\") and PeriodName in (\"Month\")";
            result = dataSource.SelectAsync(credentials, query).Result.Data;
            Assert.IsTrue(Comp("AnualIRR", "AnualIRR", FormatType.Numeric, "Numeric", "PC", "Month", result));

            query.Filter = "Id in (\"IRR\") and FormatType in (Amount) and CurrencyTypeName in (\"RC\") and PeriodName in (\"Year\")";
            result = dataSource.SelectAsync(credentials, query).Result.Data;
            Assert.IsTrue(Comp("IRR", "IRR", FormatType.Amount, "Amount", "RC", "Year", result));

            
            var val1 = "AnualIRRNumericQCMonth";
            var val2 = "AnualIRRAmountQCMonth";
            var masterSet = new HashSet<int>() {val1.GetHashCode(), val2.GetHashCode()};
            query.Filter = "Id in (\"AnualIRR\") and FormatType in (Numeric, Amount) and CurrencyTypeName in (\"QC\") and PeriodName in (\"Month\")";
            result = dataSource.SelectAsync(credentials, query).Result.Data;
            Assert.IsTrue((result["Id"].Length == 2)&& (result["Title"].Length == 2)&& (result["FormatType"].Length == 2)&& (result["TypeName"].Length == 2)&& (result["CurrencyTypeName"].Length == 2)&& (result["PeriodName"].Length == 2));
            val1 = result["Id"].GetValue(0).ToString() +
                   result["TypeName"].GetValue(0) + result["CurrencyTypeName"].GetValue(0) +
                   result["PeriodName"].GetValue(0);
            val2 = result["Id"].GetValue(1).ToString() +
                   result["TypeName"].GetValue(1) + result["CurrencyTypeName"].GetValue(1) +
                   result["PeriodName"].GetValue(1);
            var resSet = new HashSet<int>() {val1.GetHashCode(), val2.GetHashCode()};
            Assert.IsTrue(masterSet.SetEquals(resSet));

            val1 = "IRRNumericQCMonth";
            val2 = "AnualIRRNumericQCMonth";
            masterSet = new HashSet<int>() { val1.GetHashCode(), val2.GetHashCode() };
            query.Filter = "Id in (\"IRR\",\"AnualIRR\") and FormatType in (Numeric) and CurrencyTypeName in (\"QC\") and PeriodName in (\"Month\")";
            result = dataSource.SelectAsync(credentials, query).Result.Data;
            Assert.IsTrue((result["Id"].Length == 2) && (result["Title"].Length == 2) && (result["FormatType"].Length == 2) && (result["TypeName"].Length == 2) && (result["CurrencyTypeName"].Length == 2) && (result["PeriodName"].Length == 2));

            val1 = result["Id"].GetValue(0).ToString() +
                   result["TypeName"].GetValue(0) + result["CurrencyTypeName"].GetValue(0) +
                   result["PeriodName"].GetValue(0);
            val2 = result["Id"].GetValue(1).ToString() +
                   result["TypeName"].GetValue(1) + result["CurrencyTypeName"].GetValue(1) +
                   result["PeriodName"].GetValue(1);
            resSet = new HashSet<int>() { val1.GetHashCode(), val2.GetHashCode() };
            Assert.IsTrue(masterSet.SetEquals(resSet));

            masterSet = new HashSet<int>();
            foreach (var id in new[] {"IRR", "AnualIRR"}) {
                foreach (var formatType in new[] {"Numeric", "Amount"}) {
                    foreach (var currency in new[] {"QC", "PC"}) {
                        foreach (var periodName in new[] {"Month", "Year"}) {
                            masterSet.Add((id + formatType + currency + periodName).GetHashCode());
                        }
                    }
                }
            }

            query.Filter = "Id in (\"IRR\",\"AnualIRR\") and FormatType in (Numeric,Amount) and CurrencyTypeName in (\"QC\",\"PC\") and PeriodName in (\"Month\",\"Year\")";
            result = dataSource.SelectAsync(credentials, query).Result.Data;
            Assert.IsTrue((result["Id"].Length == 16) && (result["Title"].Length == 16) && (result["FormatType"].Length == 16) && (result["TypeName"].Length == 16) && (result["CurrencyTypeName"].Length == 16) && (result["PeriodName"].Length == 16));

            resSet = new HashSet<int>();
            for (var i = 0; i < 16; ++ i) {
                resSet.Add((result["Id"].GetValue(i) + result["TypeName"].GetValue(i).ToString() + result["CurrencyTypeName"].GetValue(i) + result["PeriodName"].GetValue(i)).GetHashCode());
            }
            Assert.IsTrue(masterSet.SetEquals(resSet));

        }

        [TestMethod]
        public void OperationsEntityNamesWithNotNullTermLength() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21) };
            var Groupings =new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey};
            var AnalyticIds = new[] { "IRR", "AnualIRR"};
            int? PeriodTermLength =  1 ; 
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {
                    Restrictions =
                        new[] {
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.PortfolioKey, Values = new string[] {"1"}},
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.SecurityKey,Values = new string[] {"2"}}
                        },
                        OnlyIncludeActiveInvestment = true,
                        OnlyIncludeSecuritiesLinkedToAnAsset = true
                
            };

            var convGroupings = new[] { GroupingCriteria.PortfolioKey, GroupingCriteria.SecurityKey};
            var convRestValues = new[] { RestrictionCriteria.PortfolioKey, RestrictionCriteria.SecurityKey };
            var convPeriodTermUnit =  PeriodTermUnit.Years ;

            var masterSet = new HashSet<int>();
            var basestr = AnalysisDates[0].Date.ToString() + convPeriodTermUnit + PeriodTermLength;
            foreach (var id in AnalyticIds) {
                foreach (var restriction in convRestValues) {
                    foreach (var criteria in convGroupings) {
                        masterSet.Add((basestr + id + restriction + criteria).GetHashCode());
                    }
                }
            }

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };


            var result = (OperationData)dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments).Result.Data["Results"].GetValue(0);
            Assert.IsTrue(result.EntityName.Equals("AnalyticsResult"));
            Assert.IsTrue(result.Data["NodeId"].Length == masterSet.Count());
            var resSet = new HashSet<int>();
            foreach (var val in result.Data["NodeId"]) { resSet.Add(val.GetHashCode()); }
            Assert.IsTrue(masterSet.SetEquals(resSet));
        }

        [TestMethod]
        public void OperationsEntityNamesWithoutTermLength() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21) };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = null;
            PeriodTermUnitEnum? PeriodTermUnits = null;
            var RestrictionSet = new RestrictionSetEntity() {
                Restrictions =
                        new[] {
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.PortfolioKey, Values = new string[] {"1"}},
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.SecurityKey,Values = new string[] {"2"}}
                        },
                OnlyIncludeActiveInvestment = true,
                OnlyIncludeSecuritiesLinkedToAnAsset = true

            };

            var convGroupings = new[] { GroupingCriteria.PortfolioKey, GroupingCriteria.SecurityKey };
            var convRestValues = new[] { RestrictionCriteria.PortfolioKey, RestrictionCriteria.SecurityKey };

            var masterSet = new HashSet<int>();
            var basestr = AnalysisDates[0].Date.ToString();
            foreach (var id in AnalyticIds) {
                foreach (var restriction in convRestValues) {
                    foreach (var criteria in convGroupings) {
                        masterSet.Add((basestr + id + restriction + criteria).GetHashCode());
                    }
                }
            }

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };


            var result = (OperationData)dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments).Result.Data["Results"].GetValue(0);
            Assert.IsTrue(result.EntityName.Equals("AnalyticsResult"));
            Assert.IsTrue(result.Data["NodeId"].Length == masterSet.Count());
            var resSet = new HashSet<int>();
            foreach (var val in result.Data["NodeId"]) { resSet.Add(val.GetHashCode()); }
            Assert.IsTrue(masterSet.SetEquals(resSet));
        }

        [TestMethod]
        public void NullAnalysisDates() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = 1;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {
                Restrictions =
                      new[] {
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.PortfolioKey, Values = new string[] {"1"}},
                            },
                OnlyIncludeActiveInvestment = true,
                OnlyIncludeSecuritiesLinkedToAnAsset = true

            };

            var arguments = new OperationData("Calculate", false) {
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }

        [TestMethod]
        public void MoreThanOneAnalysisDates() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21), new DateTime(2014, 12, 22) };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = 2;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {
                Restrictions =
          new[] {
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.PortfolioKey, Values = new string[] {"1"}},
                },
                OnlyIncludeActiveInvestment = true,
                OnlyIncludeSecuritiesLinkedToAnAsset = true

            };

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }

        [TestMethod]
        public void InvalideAnalysisDates() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { DateTime.MinValue.Date };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = 2;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {
                Restrictions =
          new[] {
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.PortfolioKey, Values = new string[] {"1"}},
                },
                OnlyIncludeActiveInvestment = true,
                OnlyIncludeSecuritiesLinkedToAnAsset = true

            };

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }

        [TestMethod]
        public void NullAnalyticIds() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21) };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            int? PeriodTermLength = 2;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {
                Restrictions =
          new[] {
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.PortfolioKey, Values = new string[] {"1"}},
                },
                OnlyIncludeActiveInvestment = true,
                OnlyIncludeSecuritiesLinkedToAnAsset = true

            };

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }

        [TestMethod]
        public void NullRestrictionSet() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21) };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = 2;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }

        [TestMethod]
        public void InvalideRestrictionSet1() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21) };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = 2;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {Restrictions = null};

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }


        [TestMethod]
        public void InvalideRestrictionSet2() {
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21) };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = 2;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {
                Restrictions = new RestrictionEntity[] {},
                OnlyIncludeActiveInvestment = true,
                OnlyIncludeSecuritiesLinkedToAnAsset = true
            };

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }

        [TestMethod]
        public void NullUser() {
            userDataManager.Setup(x => x.Find(It.IsAny<User.KeySet>())).Returns(() => null);
            var dataSource = new DataSourceAdapterCalculationEngine(new CalculationEngineFacadeStub(), userDataManager.Object);
            dataSource.Initialize();
            var credentials = new OperationCredentials(Environment.UserName.ToUpper());

            var AnalysisDates = new[] { new DateTime(2014, 12, 21) };
            var Groupings = new[] { GroupingCriteriaEnum.PortfolioKey, GroupingCriteriaEnum.SecurityKey };
            var AnalyticIds = new[] { "IRR", "AnualIRR" };
            int? PeriodTermLength = 1;
            PeriodTermUnitEnum? PeriodTermUnits = PeriodTermUnitEnum.Years;
            var RestrictionSet = new RestrictionSetEntity() {
                Restrictions =
                      new[] {
                            new RestrictionEntity {Criteria = RestrictionCriteriaEnum.PortfolioKey, Values = new string[] {"1"}},
                            },
                OnlyIncludeActiveInvestment = true,
                OnlyIncludeSecuritiesLinkedToAnAsset = true

            };

            var arguments = new OperationData("Calculate", false) {
                {"AnalysisDates", new[] {AnalysisDates }},
                { "Groupings", new[] { Groupings}  },
                { "AnalyticIds", new[] { AnalyticIds} },
                { "RestrictionSet", new[] { RestrictionSet} },
                { "PeriodTermUnit",  new[] { PeriodTermUnits}},
                { "PeriodTermLength",  new[] {PeriodTermLength} }
            };
            Should.Throw<OperationException>(() => dataSource.InvokeAsync(credentials, "CalculateAnalytics", arguments));
        }

    }
}
